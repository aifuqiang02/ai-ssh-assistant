---
description: AI SSH Assistant 项目开发规则和最佳实践
globs:
alwaysApply: true
---

# 项目开发规则

## 🏗️ 架构原则

### 1. 双模式服务架构
- **必须**使用统一的服务接口，提供本地（Local IPC）和云端（Remote API）两种实现
- **禁止**在组件中直接判断存储模式或直接调用 IPC/API
- **使用** `createService(LocalImpl, ApiImpl)` 自动选择实现

```typescript
// ✅ 正确
import { chatService } from '@/services/chat.service'
const sessions = await chatService.getSessions()

// ❌ 错误
if (isLocalMode) {
  await window.electronAPI.chat.getSessions()
} else {
  await fetch('/api/chat/sessions')
}
```

### 2. 状态管理
- **禁止**使用 Pinia Store（已完全废弃并删除）
- **使用** Vue Composables 管理全局 UI 状态（如 `useApp`, `useTheme`）
- **使用**直接服务调用获取业务数据
- **存储目录已删除**: `apps/desktop/src/stores/` 不应再创建

### 3. userId 处理
- **禁止**组件手动获取或传递 userId
- **必须**由服务层自动处理：
  - 本地模式：固定使用 `'local-user'`
  - 云端模式：从 JWT Token 自动提取

```typescript
// ✅ 正确 - 服务层自动处理
class ChatLocalImpl {
  async getSessions() {
    const userId = this.getUserId()  // 自动返回 'local-user'
    return window.electronAPI.chat.getSessions(userId)
  }
}

// ❌ 错误 - 组件手动处理
const userId = localStorage.getItem('userId')
await chatService.getSessions(userId)
```

## 📝 代码规范

### 1. API 路径规范
- **禁止**在 API 实现中添加 `/api` 前缀（BaseApiImpl 已包含 `/api/v1`）
- **格式**: `/模块/操作` 或 `/模块/:id`

```typescript
// ✅ 正确
class ChatApiImpl extends BaseApiImpl {
  async getChatTree() {
    return this.get('/chat/tree')  // 最终: /api/v1/chat/tree
  }
}

// ❌ 错误
return this.get('/api/chat/tree')  // 错误: /api/v1/api/chat/tree
```

### 2. IPC 命名规范
- **格式**: `模块:操作`
- **示例**: `chat:getChatTree`, `ssh:connect`, `settings:save`

```typescript
// ✅ 正确
ipcMain.handle('chat:getChatTree', ...)
ipcMain.handle('ssh:connect', ...)

// ❌ 错误
ipcMain.handle('getChatTree', ...)  // 缺少模块前缀
ipcMain.handle('chat_get_tree', ...)  // 使用下划线
```

### 3. 路由响应格式规范
- **必须**使用统一的响应 Schema (`packages/server/src/schemas/common.schema.ts`)
- **禁止**为每个路由重复定义详细的 response schema
- **200 响应**统一使用 `successResponseSchema`（允许任意对象，避免序列化问题）

```typescript
// ✅ 正确
import { successResponseSchema } from '../schemas/common.schema.js'

fastify.get('/settings', {
  schema: {
    description: '获取用户设置',
    tags: ['设置'],
    response: successResponseSchema  // 统一使用
  }
}, async (request, reply) => {
  return reply.send({
    success: true,
    message: '获取成功',
    data: { /* 任意结构 */ }
  })
})

// ❌ 错误 - 重复定义且可能导致序列化问题
response: {
  200: {
    type: 'object',
    properties: {
      success: { type: 'boolean' },
      data: { type: 'object' }  // 没有 additionalProperties: true
    }
  }
}
```

**为什么使用统一 Schema？**
- ✅ 避免 Fastify 序列化器因缺少 `additionalProperties: true` 而跳过字段
- ✅ 统一管理，修改响应格式只需更新一个地方
- ✅ 减少重复代码，提高可维护性
- ✅ 允许动态字段，支持灵活的响应结构

**可用的 Schema 选项**：
- `successResponseSchema` - 仅 200 响应
- `errorResponseSchema` - 错误响应（400/401/404/500）
- `standardResponseSchema` - 完整响应（成功+错误）

### 4. 类型定义同步
- **必须**同步更新 `apps/desktop/src/types/electron.d.ts`
- Preload 脚本每次添加新 API，都要更新类型定义

### 5. Token 管理
- **存储 key**: 固定使用 `'userToken'`（不是 `'token'`）
- **存储位置**: `localStorage` 或 `sessionStorage`
- **禁止**组件手动处理 Token，由服务层自动处理

```typescript
// ✅ 正确
localStorage.setItem('userToken', accessToken)

// ❌ 错误
localStorage.setItem('token', accessToken)
```

## 🗄️ 数据存储规范

### 1. 本地存储（SQLite）
- **工具**: better-sqlite3
- **表结构**:
  ```sql
  CREATE TABLE IF NOT EXISTS table_name (
    id TEXT PRIMARY KEY,
    userId TEXT NOT NULL,
    -- 业务字段
    createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
    updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  );
  CREATE INDEX IF NOT EXISTS idx_table_userId ON table_name(userId);
  ```
- **必须**使用 Prepared Statement 防止 SQL 注入
  ```typescript
  // ✅ 正确
  const stmt = this.db.prepare('SELECT * FROM notes WHERE userId = ?')
  return stmt.all(userId)
  
  // ❌ 错误
  return this.db.exec(`SELECT * FROM notes WHERE userId = '${userId}'`)
  ```

### 2. 云端存储（PostgreSQL）
- **ORM**: Prisma
- **位置**: `packages/database/prisma/schema.prisma`
- **迁移**: `pnpm prisma migrate dev --name xxx`

### 3. 服务实现位置
- **本地服务**: `apps/desktop/electron/services/`
- **IPC 处理器**: `apps/desktop/electron/ipc/`
- **云端服务**: `packages/server/src/services/`
- **API 路由**: `packages/server/src/routes/`
- **前端服务**: `apps/desktop/src/services/`

## 🔧 开发流程

### 0. 任务完成行为规范
- **禁止**在完成任务后自动执行重启命令（如 `pnpm dev`）
- **必须**在任务完成后告知用户需要手动重启
- **提示格式**: "✅ 修改完成！请手动执行 `pnpm dev` 重启应用以查看效果。"
- **原因**: 
  - 用户可能需要查看代码或进行其他操作
  - 避免频繁重启导致的进程混乱
  - 让用户掌控开发流程节奏

```typescript
// ✅ 正确 - 告知用户手动重启
console.log('✅ 修改完成！请手动执行 `pnpm dev` 重启应用。')

// ❌ 错误 - 自动重启
await runCommand('pnpm dev')
```

### 0.1. 文件管理规范
- **禁止删除参考项目**: `Chaterm-main`、`electron-egg-master`、`Roo-Code-main`、`lobe-chat-main`、`vscode-main` 目录是重要的参考项目，**绝对不能**删除或移动
- **参考项目用途**: 
  - 作为 Electron + Vue3 架构的参考实现
  - 提供打包配置的参考
  - 帮助解决技术难题时的对照代码
- **位置**: 项目根目录下的 `Chaterm-main/` 或 `d:\git-projects\ai-ssh-assistant\Chaterm-main\`

```bash
# ❌ 禁止操作
rm -rf Chaterm-main/
git rm -rf Chaterm-main/

# ✅ 正确 - 保留参考项目
# 需要时可以查看参考项目的实现
cat Chaterm-main/package.json
```

### 1. 双存储实现规范

**核心原则**：实现任何后端功能时，**必须**同时提供本地存储和远程存储两种实现方式。

#### 为什么需要双存储？
- 本地模式（Local）：使用 SQLite + IPC，无需服务器，适合单机使用
- 云端模式（Remote）：使用 PostgreSQL + HTTP API，支持多设备同步

#### 完整实现清单

**本地存储实现（Local）**：
1. ✅ 定义 SQLite 表结构（`apps/desktop/electron/services/your.service.ts`）
2. ✅ 实现本地服务逻辑（使用 better-sqlite3）
3. ✅ 注册 IPC 处理器（`apps/desktop/electron/ipc/your-handlers.ts`）
4. ✅ 更新 Preload API（`apps/desktop/electron/preload/index.ts`）
5. ✅ 更新 TypeScript 类型（`apps/desktop/src/types/electron.d.ts`）
6. ✅ 实现 LocalImpl 服务（`apps/desktop/src/services/your.service.ts`）

**远程存储实现（Remote）**：
1. ✅ 定义 Prisma Schema（`packages/database/prisma/schema.prisma`）
2. ✅ 运行数据库迁移（`pnpm prisma migrate dev`）
3. ✅ 实现后端服务（`packages/server/src/services/your.service.ts`）
4. ✅ 创建 API 路由（`packages/server/src/routes/your.routes.ts`）
5. ✅ 实现 ApiImpl 服务（`apps/desktop/src/services/your.service.ts`）

**服务整合**：
```typescript
// apps/desktop/src/services/your.service.ts
export interface IYourService {
  getData(): Promise<Data[]>
  createData(data: CreateDto): Promise<Data>
  // ... 其他方法
}

// 本地实现 - 使用 IPC + SQLite
class YourLocalImpl extends BaseLocalImpl implements IYourService {
  async getData(): Promise<Data[]> {
    const userId = this.getUserId() // 自动获取 'local-user'
    return this.electronAPI.your.getData(userId)
  }
}

// 云端实现 - 使用 HTTP API + PostgreSQL
class YourApiImpl extends BaseApiImpl implements IYourService {
  async getData(): Promise<Data[]> {
    const response = await this.apiService.get('/your/data')
    return response.data
  }
}

// 自动切换
export const yourService = createService<IYourService>(
  'YourService',
  YourLocalImpl,
  YourApiImpl
)
```

#### 实现顺序建议

1. **先实现本地存储**（快速验证功能）
   - 创建 SQLite 表
   - 实现本地服务和 IPC
   - 测试基本功能

2. **后实现远程存储**（支持云端同步）
   - 定义 Prisma Schema
   - 实现 API 和后端服务
   - 测试云端功能

3. **验证双模式切换**
   - 测试本地模式运行正常
   - 测试云端模式运行正常
   - 测试模式切换无缝

#### 常见错误

❌ **只实现本地或只实现云端**
```typescript
// 错误：只有本地实现
class YourLocalImpl implements IYourService { ... }
export const yourService = new YourLocalImpl()
```

✅ **同时提供两种实现**
```typescript
// 正确：提供双实现
export const yourService = createService<IYourService>(
  'YourService',
  YourLocalImpl,
  YourApiImpl
)
```

### 2. 添加新功能模块（详细步骤）
**本地存储部分**：
1. 定义服务接口 (`apps/desktop/src/services/your.service.ts`)
2. 实现本地服务 (`apps/desktop/electron/services/your.service.ts`)
3. 注册 IPC 处理器 (`apps/desktop/electron/ipc/your-handlers.ts`)
4. 更新 Preload 脚本 (`apps/desktop/electron/preload/index.ts`)
5. 更新类型定义 (`apps/desktop/src/types/electron.d.ts`)

**远程存储部分**：
6. 定义 Prisma Schema (`packages/database/prisma/schema.prisma`)
7. 实现云端服务 (`packages/server/src/services/your.service.ts`)
8. 创建 API 路由 (`packages/server/src/routes/your.routes.ts`)

**服务整合**：
9. 实现双模式服务（LocalImpl + ApiImpl）
10. 创建 UI 组件

### 3. Git 提交规范
- **禁止自动提交和推送**: 除非用户明确要求，否则不要执行 `git add`、`git commit` 或 `git push`
- **任务完成后**: 告知用户"✅ 任务完成！如需提交代码，请手动执行 git 操作。"
- **commit 信息要简短明确**，说明做了什么
- **不要**跳过 hooks（除非明确需要）
- **不要** force push 到 main/master（除非用户明确要求）

```bash
# ✅ 正确 - 仅在用户明确要求时执行
# 用户: "提交代码并推送"
git add . && git commit -m "简短说明" && git push

# ❌ 错误 - 任务完成后自动提交
# 完成功能实现后自动执行 git commit
```

### 4. 调试技巧
- **不要怀疑**代码未生效是因为没有编译或重启
- **使用**详细日志记录关键节点
- **验证数据流**:
  - 本地: 组件 → Service → IPC → 主进程 → SQLite
  - 云端: 组件 → Service → API → 后端 → Prisma → PostgreSQL

## ⚠️ 常见错误避免

### 1. 禁止的操作
- ❌ 创建或使用 Pinia Store（已废弃）
- ❌ 在组件中手动判断存储模式
- ❌ 手动传递 userId 参数
- ❌ 手动处理 Token
- ❌ API 路径添加重复的 `/api` 前缀
- ❌ 字符串拼接 SQL（使用 Prepared Statement）
- ❌ 直接连接远程数据库（使用 API）
- ❌ 为每个路由重复定义详细的 response schema
- ❌ 在 response schema 中定义 `type: 'object'` 而不加 `additionalProperties: true`

### 2. 必须的操作
- ✅ 使用统一服务接口
- ✅ 服务层自动处理 userId 和 Token
- ✅ 同步更新类型定义
- ✅ 使用 Prepared Statement
- ✅ 完整的错误处理
- ✅ 清理事件监听器
- ✅ 路由使用统一的 `successResponseSchema`

## 📚 参考文档

- [Service Architecture](./docs/development/service-architecture.md) - 服务架构详细说明
- [Database Storage](./docs/development/database-storage.md) - 数据存储架构
- [Best Practices](./docs/development/best-practices.md) - 最佳实践
- [Getting Started](./docs/development/getting-started.md) - 开发入门

## 🔍 代码检查清单

### 添加新功能前检查
- [ ] 是否需要定义服务接口？
- [ ] 是否需要本地和云端两种实现？
- [ ] 类型定义是否同步更新？
- [ ] IPC 命名是否符合规范？
- [ ] API 路径是否正确（无重复前缀）？
- [ ] 路由是否使用统一的 `successResponseSchema`？

### 提交代码前检查
- [ ] 是否有 TypeScript 错误？
- [ ] 是否有 linter 错误？
- [ ] userId 和 Token 是否由服务层处理？
- [ ] 是否有未清理的事件监听器？
- [ ] 是否有 SQL 注入风险？
- [ ] 是否有硬编码的配置（应使用环境变量）？

### 组件开发检查
- [ ] 是否直接使用服务而非 Store？
- [ ] 是否使用 Composables 管理全局状态？
- [ ] 是否正确清理副作用（onBeforeUnmount）？
- [ ] 是否有完整的错误处理？

## 📄 文档规范

### 禁止创建总结文档
- **禁止**在任务完成后创建总结文档（如 `*_FIX.md`、`*_COMPLETE.md`、`*_SUMMARY.md` 等）
- **原因**: 
  - 文档容易过时且难以维护
  - Git 提交历史已经记录了所有修改
  - 重要的架构说明应该写在代码注释中
  - 项目规范统一记录在 `.cursor/rules/my-rules.mdc`

```bash
# ❌ 禁止创建
apps/desktop/SSH_RECONNECT_FIX.md
apps/desktop/THEME_OPTIMIZATION.md
apps/desktop/SYSTEM_MESSAGE_HIDE_FIX.md

# ✅ 正确做法
# 1. 在代码中添加关键注释
// 修复 SSH 重连后连接 ID 不更新的问题
// 使用 currentConnectionId 而不是 actualConnectionId
:connection-id="currentConnectionId"

# 2. 提交时写清晰的 commit message
git commit -m "fix: SSH 重连后 AI 助手连接 ID 不更新

- 修改 TerminalView 传递给 AI 助手的连接 ID
- 从固定的 actualConnectionId 改为动态的 currentConnectionId
- 添加 watch 监听连接 ID 变化"
```

### 何时创建文档
**仅在以下情况**下创建文档：
- 重大架构变更（应更新 `README.md` 或 `.cursor/rules/my-rules.mdc`）
- API 文档（使用 OpenAPI/Swagger 自动生成）
- 用户使用指南（`docs/` 目录）

---

**最后更新**: 2025-10-11
**项目架构版本**: v2.0 (双模式服务架构)
